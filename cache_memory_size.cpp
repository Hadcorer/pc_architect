// cache memory size.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//
#include <iostream>
#include <cstdlib>

#include <chrono> // для функций из std::chrono
#include <ctime>

using namespace std;


// класс таймер
class Timer
{
	// Псевдонимы типов используются для удобного доступа к вложенным типам
	using time = chrono::steady_clock;		  // часы, таймер
	using seconds = chrono::duration<double>; // интервал времени, измеряемый в секундах

	// переменная для хранения времени при объявлении объекта класса
	chrono::time_point<time> t_count;

public:
	// Конструктор, при объявлении объекта текущее время становится началом отсчёта
	Timer() : t_count(time::now())
	{}

	// обнуление таймера
	void reset()
	{
		t_count = time::now();
	}

	// возвращение прошедшего времени с момента объявления объекта
	double elapsed() const
	{
		return chrono::duration_cast<seconds>(time::now() - t_count).count();
	}
};


// заполнение масссива
template <typename T>
void fill_array(T* a, int n)
{
	for (int i = 0; i < n; i++)
		a[i] = rand() % 100;
}


int main()
{
	setlocale(LC_ALL, "Russian");

	cout << "Экспериментальное демонатрация определения объема КЕШ-памяти" << endl;

	Timer t;					 // таймер

	const int n = 60000; 		 // кол-во элементов массива
	const int m = 100;			 // кол-во экспериментов

	long double* a = new long double[n]; // массив
	int size = 8;				 // размер одного элемента массива (байт)

	// заполнение массива
	fill_array(a, n);

	double max_time = 0.0000003;		 // максимальное время
	double time_old = 0;			 // промежуточное время
	double time_new = 0;

	int ind = 0;				 // индекс элемента массива, в котором произошёл скачок времени
	int avr = 0;				// средний индекс
	
	//пункт 5
	for (int i = 0; i < m; i++)
	{
		// пункты 2-4
		for (int i = 0; i < n; i++)
		{
			time_old = time_new;
			t.reset();
			int num = a[i];
			num += 100;
			a[i] = num;
			// пункт 3
			time_new = t.elapsed();
			time_old = abs(time_old - time_new);
			// пункт 4
			if (max_time < time_old)
			{
				ind = i;
			}
		}
		cout <<"Индекс = " << ind << "\t Max время = " << time_new << "\n";
		//пункт 6
		avr += ind;
	}

	//7 и 8 пункт
	avr = avr /m;
	cout <<"\nAverage index = " << avr << "\n";
	cout << avr * size << " byte\n\n" << endl;
};
// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
